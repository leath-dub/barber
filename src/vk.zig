// Vulkan helpers

const std = @import("std");
const mem = std.mem;
const log = std.log;

const c = @import("c.zig").includes;

fn camelToTitle(comptime input: []const u8) std.meta.Tuple(&.{usize, [input.len + input.len]u8}) {
    var r = std.mem.zeroes([input.len + input.len]u8);
    var length: usize = 0;
    for (input, 0..) |ch, i| {
        if (std.ascii.isUpper(ch) and !(i != 0 and std.ascii.isUpper(input[i - 1]))) {
            r[length] = '_';
            length += 1;
            r[length] = ch;
        } else {
            r[length] = std.ascii.toUpper(ch);
        }
        length += 1;
    }
    return .{ length, r };
}

pub fn SType(comptime T: type, value_: T) T {
    const typeName = @typeName(T);

    const prefix = "cimport.struct_";
    comptime if (!mem.startsWith(u8, typeName, prefix)) @compileError("Tag can only be used with vulkan types that are auto generated by @cImport");

    const actualTypeName = typeName[prefix.len..];
    comptime if (!mem.startsWith(u8, actualTypeName, "Vk")) @compileError("Expected type to start with Vk");

    const noPrefix = actualTypeName[2..];
    const len, const buf = comptime camelToTitle(noPrefix);
    const fieldName = "VK_STRUCTURE_TYPE" ++ buf[0..len];

    var value = value_;
    value.sType = @field(c, fieldName);
    return value;
}

const ShaderStage = enum(c_uint) {
    vertex,
    tesscontrol,
    tessevaluation,
    geometry,
    fragment,
    compute,
    raygen,
    intersect,
    anyhit,
    closest_hit,
    miss,
    callable,
    task,
    mesh,
};


pub fn compileShader(allocator: mem.Allocator, stage: ShaderStage, glslText: [*:0]const u8) ![]u32 {
    _ = c.glslang_initialize_process();
    defer c.glslang_finalize_process();

    const input = mem.zeroInit(c.glslang_input_t, .{
        .language  = c.GLSLANG_SOURCE_GLSL,
        .stage = @intFromEnum(stage),
        .client = c.GLSLANG_CLIENT_VULKAN,
        .client_version = c.GLSLANG_TARGET_VULKAN_1_2,
        .target_language = c.GLSLANG_TARGET_SPV,
        .target_language_version = c.GLSLANG_TARGET_SPV_1_3,
        .code = glslText,
        .default_version = 100,
        .default_profile = c.GLSLANG_NO_PROFILE,
        .messages = c.GLSLANG_MSG_DEFAULT_BIT,
        .resource = c.glslang_default_resource(),
    });

    const shader = c.glslang_shader_create(&input);
    defer c.glslang_shader_delete(shader);

    if (c.glslang_shader_preprocess(shader, &input) == 0) {
        log.err("glsl info: {s}", .{c.glslang_shader_get_info_log(shader)});
        log.err("glsl debug: {s}", .{c.glslang_shader_get_info_debug_log(shader)});
        return error.ShaderPreProcessFailed;
    }

    if (c.glslang_shader_parse(shader, &input) == 0) {
        log.err("glsl info: {s}", .{c.glslang_shader_get_info_log(shader)});
        log.err("glsl debug: {s}", .{c.glslang_shader_get_info_debug_log(shader)});
        return error.ShaderParseFailed;
    }

    const program = c.glslang_program_create();
    defer c.glslang_program_delete(program);
    c.glslang_program_add_shader(program, shader);

    if (c.glslang_program_link(program, c.GLSLANG_MSG_SPV_RULES_BIT | c.GLSLANG_MSG_VULKAN_RULES_BIT) == 0) {
        log.err("glsl info: {s}", .{c.glslang_program_get_info_log(program)});
        log.err("glsl debug: {s}", .{c.glslang_program_get_info_debug_log(program)});
        return error.ShaderLinkingFailed;
    }

    c.glslang_program_SPIRV_generate(program, @intFromEnum(stage));

    const spirv_size = c.glslang_program_SPIRV_get_size(program);
    var spirv = try allocator.alloc(u32, spirv_size);
    c.glslang_program_SPIRV_get(program, spirv.ptr);
    spirv.len = spirv_size;

    if (c.glslang_program_SPIRV_get_messages(program)) |messages| {
        log.info("SPIR-V message: {s}", .{messages});
    }

    return spirv;
}

const Result = enum(c_int) {
    SUCCESS = 0,
    NOT_READY = 1,
    TIMEOUT = 2,
    EVENT_SET = 3,
    EVENT_RESET = 4,
    INCOMPLETE = 5,
    ERROR_OUT_OF_HOST_MEMORY = -1,
    ERROR_OUT_OF_DEVICE_MEMORY = -2,
    ERROR_INITIALIZATION_FAILED = -3,
    ERROR_DEVICE_LOST = -4,
    ERROR_MEMORY_MAP_FAILED = -5,
    ERROR_LAYER_NOT_PRESENT = -6,
    ERROR_EXTENSION_NOT_PRESENT = -7,
    ERROR_FEATURE_NOT_PRESENT = -8,
    ERROR_INCOMPATIBLE_DRIVER = -9,
    ERROR_TOO_MANY_OBJECTS = -10,
    ERROR_FORMAT_NOT_SUPPORTED = -11,
    ERROR_FRAGMENTED_POOL = -12,
    ERROR_UNKNOWN = -13,
    ERROR_OUT_OF_POOL_MEMORY = -1000069000,
    ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
    ERROR_FRAGMENTATION = -1000161000,
    ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
    PIPELINE_COMPILE_REQUIRED = 1000297000,
    ERROR_SURFACE_LOST_KHR = -1000000000,
    ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
    SUBOPTIMAL_KHR = 1000001003,
    ERROR_OUT_OF_DATE_KHR = -1000001004,
    ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
    ERROR_VALIDATION_FAILED_EXT = -1000011001,
    ERROR_INVALID_SHADER_NV = -1000012000,
    ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR = -1000023000,
    ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR = -1000023001,
    ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR = -1000023002,
    ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR = -1000023003,
    ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR = -1000023004,
    ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR = -1000023005,
    ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
    ERROR_NOT_PERMITTED_KHR = -1000174001,
    ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,
    THREAD_IDLE_KHR = 1000268000,
    THREAD_DONE_KHR = 1000268001,
    OPERATION_DEFERRED_KHR = 1000268002,
    OPERATION_NOT_DEFERRED_KHR = 1000268003,
    ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR = -1000299000,
    ERROR_COMPRESSION_EXHAUSTED_EXT = -1000338000,
    INCOMPATIBLE_SHADER_BINARY_EXT = 1000482000,
    PIPELINE_BINARY_MISSING_KHR = 1000483000,
    ERROR_NOT_ENOUGH_SPACE_KHR = -1000483000,
    RESULT_MAX_ENUM = 2147483647,
};

pub fn result(r: c.VkResult) Result {
    return @enumFromInt(r);
}

pub fn check(r: c.VkResult) !void {
    const er = result(r);
    switch (er) {
        .SUCCESS => return,
        else => {
            log.err("checking result of vulkan API call failed with: {s}", .{ @tagName(er) });
            return error.Failed;
        }
    }
    return;
}
